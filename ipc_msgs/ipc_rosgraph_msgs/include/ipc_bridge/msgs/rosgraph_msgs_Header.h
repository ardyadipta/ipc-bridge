/* automatically generated by xdrgen from xdr/rosgraph_msgs_Header.xdr
 * xdrgen cvs version: $Revision: 1.7 $ $Date: 2009/01/12 15:54:59 $
 * xdr/rosgraph_msgs_Header.xdr last modified: Wed May 18 17:17:25 2011
 */

#ifndef INCrosgraph_msgs_Header_h
#define INCrosgraph_msgs_Header_h



#include <cstring>


struct rosgraph_msgs_Header {
  unsigned int seq;
  double stamp;
  char *frame_id;
#define rosgraph_msgs_Header_IPC_FORMAT "{uint,double,string}"
  static const char *getIPCFormat(void) {
    return rosgraph_msgs_Header_IPC_FORMAT;
  }


  rosgraph_msgs_Header() : seq(0), stamp(0)
  {
    frame_id = new char[1];
    frame_id[0] = '\0';
  }
  rosgraph_msgs_Header(const rosgraph_msgs_Header& msg) :
    seq(msg.seq), stamp(msg.stamp)
  {
    frame_id = new char[strlen(msg.frame_id) + 1];
    strcpy(frame_id, msg.frame_id);
  }
  ~rosgraph_msgs_Header()
  {
    if (frame_id != 0)
      delete[] frame_id;
  }
  rosgraph_msgs_Header& operator= (const rosgraph_msgs_Header& msg)
  {
    seq = msg.seq;
    stamp = msg.stamp;

    if (frame_id != 0)
      delete[] frame_id;

    frame_id = new char[strlen(msg.frame_id) + 1];
    strcpy(frame_id, msg.frame_id);

    return *this;
  }

};


namespace ipc_bridge
{
    typedef rosgraph_msgs_Header Header;
}


#endif /* INCrosgraph_msgs_Header_h */
